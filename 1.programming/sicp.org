* Personal Glossary

- <<prefix notation>> ::

  - Putting the operator to the left of the operands.  Contrast it to
    ‘infix notation’, for example, in addition:

    - prefix notation: ~+ 1 2 3 4 5~
    - infix notation: ~1 + 2 + 3 + 4 + 5~

    See also some [[prefix-notation-advantages][advantages of using prefix notation for procedure
    application]]

- <<primitive>> ::

- <<expression>> ::

  - Something that can be ‘evaluated’, ie, resolves to a value.

  - There are [[primitive expressions]], example, a number (evaluates to
    the number value), and there are [[compound expressions]], for
    example, a procedure application over its arguments (which is a
    combination made of sub expressions).

- <<programming language>> ::

  - [[programing-language-process-idea-framework][Framework for organizing ideas about processes.]]

- <<idiom>> <<idioms>> ::

  - plural: small, standard correct structures used in composing
    greater progams.  See the [[foreword-idiom-definition-quote]]

- <<algorithm>> ::

  - A program that perform a precise mathematical function, where is
    desired that they behave optimally, specially regarding execution
    time and storage.  See the [[foreword-algorithm-definition-quote]]

- <<procedural epistemology>> ::

  - Study of the structure of knowledge in an imperative point of
    view.  It answers ‘how to’ instead of ‘what is’.  See
    [[preface-1e-procedural-epistemology-quote]]

- <<process>> ::

  - For a lax description, see [[Process, data, and program]]

- <<data>> ::

  - For a lax description, see [[Process, data, and program]]

- <<program>> ::

  - For a lax description, see [[Process, data, and program]]

- <<interpreter>> ::

- <<LISP>> ::

  - LISt Processing


* Notes

** [[info:sicp#Foreword][Foreword]]

- Sets three foci of consideration:

  - The mind:  Every program is a model that starts in the mind.

  - Collection of computer programs: a knowledge of correct idioms and
    proven techniques for combining them.

  - The computer: The computer obeys the laws of physics, another model.

- Idioms definition quote:

  <<foreword-idiom-definition-quote>>
  #+begin_quote
  (...) complete formal arguments of correctness seldom accompany large
  programs.  Since large programs grow from small ones, it is crucial
  that we develop an arsenal of standard program structures of whose
  correctness we have become sure--we call them idioms--and learn to
  combine them into larger structures using organizational techniques of
  proven value.
  #+end_quote

- Algorithm definition quote:

  <<foreword-algorithm-definition-quote>>
  #+begin_quote
  Among the programs we write, some (but never enough) perform a
  precise mathematical function such as sorting or finding the maximum
  of a sequence of numbers, determining primality, or finding the
  square root.  We call such programs algorithms, and a great deal is
  known of their optimal behavior, particularly with respect to the
  two important parameters of execution time and data storage
  requirements.
  #+end_quote

- Advice

  #+begin_quote
  A programmer should acquire good algorithms and idioms.
  #+end_quote


** [[info:sicp#Preface 1e][Preface 1e]]

- Computer programs can be a formal medium for expressing
  methodological ideas:

  #+begin_quote
  (...) a computer language is not just a way of getting a computer to
  perform operations but rather that it is a novel formal medium for
  expressing ideas about methodology.
  #+end_quote

- Procedural epistemology quote

  <<preface-1e-procedural-epistemology-quote>>
  #+begin_quote
  (...) "procedural epistemology" -- the study of the structure of
  knowledge from an imperative point of view, as opposed to the more
  declarative point of view taken by classical mathematical subjects.
  Mathematics provides a framework for dealing precisely with notions
  of "what is."  Computation provides a framework for dealing
  precisely with notions of "how to."
  #+end_quote


** [[info:sicp#Chapter 1][Building Abstractions With Procedures]]

- <<Process, data, and program>> :
  - process :: beings that inhabits a computer
  - data :: abstract things manipulated by processes
  - program :: pattern of rules that directs a process

  So we could say, a process, the thing living in the computer,
  manipulates data directed by the program.

- On good engineering:

  - Organize programs in such a way that:

    - We can be reasonable sure they will perform the intended tasks.
    - Unanticipated problems don’t lead to catastrophe.
    - Problems can be debugged.
    - Are modular: new parts can be made or replaced indepently.

  - Visualize process behaviour in advance


*** [[info:sicp#1-1][The Elements of Programming]]

- On programming languages:

  - They can be understood as a framework for organizing ideas about
    processes.  <<programing-language-process-idea-framework>>

    Thus when thinking about a language we should ask ourselves, what
    are the means the language provides for combining simple ideas
    into complex ideas?

  - In regards to organizing ideas about processes, powerful
    languages provides the following mechanisms:

    - Primitive expressions: Simplest entities the language is
      concerned with.

    - Means of combination: Used to make compound elements.

    - Means of abstraction: by which compound elements can be *named*
      and manipulated as units.

    :personal-note:
    Here we are reasonating about ‘processes’ (not about data, or data
    structures, for example).  When it’s said about primitive
    expressions that they are entities/elements, the meaning is of
    objects that produce values when ‘evaluated’.
    :end:

    This dynamic objects can be combined to make compound evaluable
    objects, and abstracted with names to reffer to the compound
    expression with a name.

  - Altough the same is also true about data, programming languages
    should provide these mechanisms for both using / describing /
    defining and combining data and procedures.


**** [[info:sicp#1-1-1][Expressions]]

- [[expression]] (in glossary)

- An statement/description that can be evaluated, ie, reduced to a
  single value.

- There are <<primitive expressions>> :

  - Representing numbers: for integers, the numbers typed as
    themselves, evaluate to those numbers:

    #+begin_src scheme
      27
    #+end_src

    #+RESULTS:
    : 27

  - representing procedures: for example, the procedure to add ‘+’
    is a primitive procedure.

    #+begin_src scheme
      +
    #+end_src

    #+RESULTS:
    : #<procedure + (#:optional _ _ . _)>

- And there are <<compound expressions>> :

  - Representing procedure application.  For example, add
    ‘+’ can be combined with number expressions to represent the
    adding application, ie, sum:

    #+begin_src scheme
      (+ 1 2 3 4 5)
    #+end_src

    #+RESULTS:
    : 15

  - This type of compound expression representing procedure
    application will be called a /combination/.  In a combination, the
    first element is the operator and the rest are the operands.

    Putting the operator first and the arguments later is called
    [[prefix notation]].

    :personal-note:
    I guess its called combination as in, combination of expressions.
    The combination in itself its also an expression, because it
    evaluates, it produces a value.  Simple ideas get combined to
    represent a complex idea.  The framework for thinking about
    processes: define simple ideas, define a way to combine them,
    create complex ideas through the combinations.

    It makes me remember of factoring in math.  You can think of
    big numbers as the product of their prime factors.  This
    decomposition can help us: by performing easier steps first (for
    example, canceling factors by divisors), calculating the result
    (that is, evaluating) becomes much easier.
    :end:

  - Prefix notation has the following advantages in regarding to
    procedure application <<prefix-notation-advantages>> :

    - Being able to accomodate an arbitrary number of arguments.

      - infix sum, always takes two args: ~1 + 2~, that is,
        ~left + right~

      - prefix sum can take any: ~+ 1 2 3 4 5 ... n~

    - Unambigous order of operations: The operator is always the first
      element, and each operation is always delimited.

      In infix notation, we require to know the arity of each
      operation, and we need parenthesis to override the natural
      order of each operation.  For example:

      #+begin_src python
        return 1 + 2 * 3 - 1 / 2
      #+end_src

      #+RESULTS:
      : 6.5

      The general rule is, first multiply and divide in the order of
      appareance, then add and substract in order of appearance.

      In prefix notation theres no need to know arity, every operation
      is delimited:

      #+begin_src scheme
        (- (+ 1
              (* 2 3))
           (/ 1 2))
      #+end_src

      #+RESULTS:
      : 13/2

- The interpreter works by evaluating expressions one and a time, and
  printing their results.  That is why it’s said that it works in a
  ‘read-eval-print’ loop, also know as ‘repl’


**** [[info:sicp#1-1-2][Naming and the Environment]]

- Languages allow /to name/ computational objects

- A name identifies a "variable", whose "value" is a computational object.


**** Evaluating Combinations

TODO: refactor this
the combination’s result value is obtained by evaluating each
expression of the combination, and applying the first
element’s value (the operation) to the arguments (the value
of the rest of the operators, when evaluated).

Personal note: This is not so different of other programming
languages with infix notation, ~1 + 2 + 3 + 4 + 5~, the add
operation takes two arguments, the expression ‘1 + 2’ evaluates
the left side, the right side, and /then/ applies the addition on
the arguments.



**** Compound Procedures

**** The Substitution Model for Procedure Application

**** Conditional Expressions and Predicates

**** Example: Square Roots by Newton's Method

**** Procedures as Black-Box Abstractions

*** Procedures and the Processes They Generate

*** Linear Recursion and Iteration

**** Tree Recursion

**** Orders of Growth

**** Exponentiation

**** Greatest Common Divisors

**** Example: Testing for Primality

*** Formulating Abstractions with Higher-Order Procedures

**** Procedures as Arguments

**** Constructing Procedures Using `Lambda'

**** Procedures as General Methods

**** Procedures as Returned Values

** Building Abstractions with Data

*** Introduction to Data Abstraction

**** Example: Arithmetic Operations for Rational Numbers

**** Abstraction Barriers

**** What Is Meant by Data?

**** Extended Exercise: Interval Arithmetic

*** Hierarchical Data and the Closure Property

**** Representing Sequences

**** Hierarchical Structures

**** Sequences as Conventional Interfaces

**** Example: A Picture Language

*** Symbolic Data

**** Quotation

**** Example: Symbolic Differentiation

**** Example: Representing Sets

**** Example: Huffman Encoding Trees

*** Multiple Representations for Abstract Data

**** Representations for Complex Numbers

**** Tagged data

**** Data-Directed Programming and Additivity

*** Systems with Generic Operations

**** Generic Arithmetic Operations

**** Combining Data of Different Types

**** Example: Symbolic Algebra

** Modularity, Objects, and State

*** Assignment and Local State

**** Local State Variables

**** The Benefits of Introducing Assignment

**** The Costs of Introducing Assignment

*** The Environment Model of Evaluation

**** The Rules for Evaluation

**** Applying Simple Procedures

**** Frames as the Repository of Local State

**** Internal Definitions

*** Modeling with Mutable Data

**** Mutable List Structure

**** Representing Queues

**** Representing Tables

**** A Simulator for Digital Circuits

**** Propagation of Constraints

*** Concurrency: Time Is of the Essence

**** The Nature of Time in Concurrent Systems

**** Mechanisms for Controlling Concurrency

*** Streams

**** Streams Are Delayed Lists

**** Infinite Streams

**** Exploiting the Stream Paradigm

**** Streams and Delayed Evaluation

**** Modularity of Functional Programs and Modularity of Objects

** Metalinguistic Abstraction

*** The Metacircular Evaluator

**** The Core of the Evaluator

**** Representing Expressions

**** Evaluator Data Structures

**** Running the Evaluator as a Program

**** Data as Programs

**** Internal Definitions

**** Separating Syntactic Analysis from Execution

*** Variations on a Scheme -- Lazy Evaluation

**** Normal Order and Applicative Order

**** An Interpreter with Lazy Evaluation

**** Streams as Lazy Lists

*** Variations on a Scheme -- Nondeterministic Computing

**** Amb and Search

**** Examples of Nondeterministic Programs

**** Implementing the `Amb' Evaluator

*** Logic Programming

**** Deductive Information Retrieval

**** How the Query System Works

**** Is Logic Programming Mathematical Logic?

**** Implementing the Query System

*** Implementing the Query System

**** The Driver Loop and Instantiation

**** The Evaluator

**** Finding Assertions by Pattern Matching

**** Rules and Unification

**** Maintaining the Data Base

**** Stream Operations

**** Query Syntax Procedures

**** Frames and Bindings

** Computing with Register Machines

*** Designing Register Machines

**** A Language for Describing Register Machines

**** Abstraction in Machine Design

**** Subroutines

**** Using a Stack to Implement Recursion

**** Instruction Summary

*** A Register-Machine Simulator

**** The Machine Model

**** The Assembler

**** Generating Execution Procedures for Instructions

**** Monitoring Machine Performance

*** Storage Allocation and Garbage Collection

**** Memory as Vectors

**** Maintaining the Illusion of Infinite Memory

*** The Explicit-Control Evualtor

**** The Core of the Explicit-Control Evaluator

**** Sequence Evaluation and Tail Recursion

**** Conditionals, Assignments, and Definitions

**** Running the Evaluator

*** Compilation

**** Structure of the Compiler

**** Compiling Expressions

**** Compiling Combinations

**** Combining Instruction Sequences

**** An Example of Compiled Code

**** Lexical Addressing

**** Interfacing Compiled Code to the Evaluator
